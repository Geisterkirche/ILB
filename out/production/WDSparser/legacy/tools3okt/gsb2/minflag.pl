use strict;
open(g, "wc_gsb2_param.dat") or die ("=( error");        	# открывает файл file в переменную g wc_gsb2_param
open(h,">", "WDS=CCDM_sort.dat") or die ("=( error");	# создаёт файл script, в который пишется вывод отправленный на переменную h
#open(h1,">", "WDS=CCDM_sort_rem.dat") or die ("=( error");	# создаёт файл script, в который пишется вывод отправленный на переменную h
#open(h1, ">", "1.dat") or die ("=( error"); 
my($id, $j, $i, $x, %h, @m,@f,@d, @i2,@im2, $j2,$fl,$j1, $k1,$l1, $a,$D1, $id2, $b, $k, @rh, $l, $dn,$s, $z1, $D,$z,$ds,$aa,$m1, $m2, $r, $rt, $t, $tt,$F,$k,$F1);
$z1 = 0;
$i = "00003+7305 AB ";
#$i2= "00004+7305 AB     ";
$z = 0;
$a=0;
$aa=0;
@i2=();
@im2=();
$fl=0;
while(defined($x=<g>))				# <g> означает одна строчка из файла g,соотв.здесь цикл бежит по строчкам сверху вниз.	
{
		if($z==0) {$z=$z+1;
	chomp($x);  
	print h   ($x);
  next;};
  chomp($x);
  $z1++;
  $id  = substr($x,  77, 14);
  $id2 = substr($x,  91, 17);
  #$j = substr($x,  48, 10);
  $D  = substr($x,  12, 7);
  
  $m1  = substr($x,  2, 1);
  $m2  = substr($x,  3, 1);
  $r  = substr($x,  4, 1);
  $rt  = substr($x,  5, 1);
  $t  = substr($x,  6, 1);
  $tt  = substr($x,  7, 1);
  $dn  = substr($x,  8, 1);
 

  if ($m1 =~ "n") {$m1=0;}    if ($m1==2) {$m1=0;}
  if ($m2 =~ "n") {$m2=0;}    if ($m2==2) {$m2=0;}
  if ($r =~ "n")   {$r=0;}    if ($r==2)   {$r=0;}
  if ($rt =~ "n") {$rt=0;}    if ($rt==2) {$rt=0;}
  if ($t =~ "n")   {$t=0;}    if ($t==2)   {$t=0;}
  if ($tt =~ "n") {$tt=0;}    if ($tt==2) {$tt=0;}
  
  $F= $m1 + $m2 + $r + $rt + $t + $tt + $dn;
  
  #===========================================
  #ПРОВЕРКА НА СУЩЕТВОВАНИЕ В СПИСКЕ ПАРЫ WDS
  $fl=0;
   $k1 = scalar(@i2);
   for ($j=0;$j<=$k1;$j++) {
     if (@i2[$j] eq $id2) { $fl++;} 
   }
   #printf h1 ($fl."\n"); 
   if ($fl==0) {
    #заполняем массивы
    push(@f, $F);
    push(@d, $D);
    push(@im2, $id2);
    push(@m, $x);
   }
  #===========================================
  
  if ($i ne $id) {
   pop (@m); # удаляет последний элемент в массиве (то есть тот который справа)
   pop (@f);
   pop (@d);
   pop (@im2);
   
   $k = scalar(@m); # считает количество элементов в массиве

   #===========================================
   #===========================================
   # ОСНОВНОЙ КОД СОРТИРОВКИ
   #print h "@rh";
   $F1 = @f[0];

   $l=0;
   for ($j=1;$j<$k;$j++) {
   if ($F1>=@f[$j]) {
      $F1 = @f[$j];$l=$j;
      } 
   }
   
   for ($j=0;$j<$k;$j++) {
   if (@f[$j]==$F1) {
   $D1 = @d[$j]; next;}}
   
   $l1=0;
      for ($j=0;$j<$k;$j++) {
   if (@f[$j]==$F1) {
    if ($D1>=@d[$j]) {
      $D1 = @d[$j];$l1=$j;
      } 

      }
   }
   $s=@m[$l1];
   if ($k!=0) {
   print h ($s);} 
   
   # ОСНОВНОЙ КОД СОРТИРОВКИ
   #====================================== 
   #======================================
   
   
   #$id2=substr(@m[$l1],  62, 17);
   push(@i2, substr(@m[$l1],  91, 17));   #  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<=    id2!
   
   $fl=0;
   $k1 = scalar(@i2);
   for ($j=0;$j<=$k1;$j++) {
   if (@i2[$j] eq $id2) {$fl++;} 
   }
   #printf h1 ($fl."\n");
   #=======================================
   #====================================== 
   $i=$id;
   if ($fl!=0) {
   @m=(); @f=(); @d=(); @im2=()}
   else{
    $aa++;
   
   @m = 1; # присваивание числа массиву - массив состоим из ОДНОГО (нулевого) элемента, равного единице
   @m[0]=$x; # заменяем нулевой элемент строчкой $x
   @f = 1;
   @f[0]=$F; 
   @d = 1;
   @d[0]=$D;
   @im2 = 1;
   @im2[0]=$id2;}
   
   }
  else {next;}
  
  
  
  }
  


